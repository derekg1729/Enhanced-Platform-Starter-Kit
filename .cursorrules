{
  "version": "2.11",
  "meta": {
    "description": "Core rules for the agent-platform project",
    "stateFile": "docs/systematic-dev/workflow-state.md",
    "priority": [
      "Always check workflow-state.md first to determine current context",
      "Follow the Test-Driven Development workflow strictly",
      "Never skip writing tests before implementation",
      "Always run all tests before committing changes",
      "NEVER bypass pre-commit hooks with --no-verify under ANY circumstances"
    ]
  },
  "WORKFLOW_KEY": {
    "TDD": {
      "description": "Test-Driven Development is the foundation of our development process",
      "overview": "This workflow ensures that tests are written before implementation, code changes are minimal and focused, and all tests pass before completion. All other workflows (Bug Resolution, Documentation Updates) must follow these core TDD principles.",
      "stages": {
        "DESIGN": {
          "description": "Design the feature and plan implementation",
          "actions": "Define feature requirements, plan implementation, identify files to modify",
          "artifacts": "Update feature-design.md with detailed design",
          "exitCriteria": "Complete design document with all files identified",
          "nextStage": "PRE_TESTING",
          "updateInstructions": "Update workflow-state.md to STAGE_KEY: PRE_TESTING when design is complete",
          "instructions": [
            "Create a detailed design for the feature implementation",
            "Identify ALL files that will need to be modified",
            "Identify any new files that need to be created",
            "Document dependencies between files and the order of changes",
            "Consider performance, security, and scalability implications",
            "Check for alignment with architectural principles",
            "CRITICAL: Identify ALL test files that will be affected by the changes",
            "CRITICAL: Document this design in docs/systematic-dev/feature-design.md before proceeding"
          ]
        },
        "PRE_TESTING": {
          "description": "Write failing tests for all functionality",
          "actions": "Create or update test files for all components/functions",
          "artifacts": "New/updated test files",
          "exitCriteria": "All tests written and confirmed to fail for expected reasons",
          "nextStage": "IMPLEMENTATION",
          "updateInstructions": "Update workflow-state.md to STAGE_KEY: IMPLEMENTATION when tests are verified",
          "instructions": [
            "Create or update test files for all components/functions that will be modified",
            "Write comprehensive tests that cover all expected behaviors",
            "Include tests for edge cases and error handling",
            "Ensure tests are properly structured and follow testing best practices",
            "For bug fixes, write tests that reproduce the bug",
            "CRITICAL: Update ALL existing tests that will be affected by the changes",
            "CRITICAL: Complete ALL test writing before proceeding to the next step",
            "Run the newly written tests to confirm they fail",
            "Verify that tests fail for the expected reasons",
            "Document the test failures as evidence that the tests are properly checking for the new functionality"
          ]
        },
        "IMPLEMENTATION": {
          "description": "Implement the feature code to make tests pass",
          "actions": "Write minimal code to make tests pass",
          "artifacts": "New/updated implementation files",
          "exitCriteria": "Minimal implementation that makes tests pass",
          "nextStage": "VALIDATION",
          "updateInstructions": "Update workflow-state.md to STAGE_KEY: VALIDATION when implementation is complete",
          "instructions": [
            "Implement the feature according to the design",
            "ONLY modify files that were identified in the design phase",
            "If additional files need modification, return to the design phase",
            "Follow coding standards and best practices",
            "Implement the minimal code needed to make tests pass",
            "Focus on making tests pass first, not perfect code",
            "Run tests frequently during implementation to track progress"
          ]
        },
        "VALIDATION": {
          "description": "Run all tests, verify feature works as expected",
          "actions": "Run full test suite, fix any issues",
          "artifacts": "Test results, any bug fixes",
          "exitCriteria": "All tests passing, feature meets acceptance criteria",
          "nextStage": "COMPLETION",
          "updateInstructions": "Update workflow-state.md to STAGE_KEY: COMPLETION when all tests pass",
          "instructions": [
            "Run the complete test suite, not just the new tests",
            "Verify that all tests are now passing",
            "If any tests are failing, fix the implementation",
            "If ANY existing tests start failing unexpectedly, stop and investigate immediately",
            "Failing tests are a signal that something is wrong, not that the tests need to be changed",
            "CRITICAL: Do not proceed until ALL tests are passing",
            "CRITICAL: A feature is NOT complete until ALL tests pass, not just the ones you wrote",
            "Refactor for readability and maintainability if needed",
            "Optimize performance if needed",
            "Run tests after each significant change",
            "Ensure all tests continue to pass",
            "Run the build process to ensure it completes successfully",
            "Fix ANY build errors before proceeding - NEVER commit code that doesn't build"
          ]
        },
        "COMPLETION": {
          "description": "Update documentation, commit changes",
          "actions": "Update documentation, commit code",
          "artifacts": "Updated backlog.md, commit",
          "exitCriteria": "Changes committed, task marked complete",
          "nextStage": "DESIGN (new feature)",
          "updateInstructions": "After committing, update workflow-state.md to STAGE_KEY: DESIGN and FEATURE_KEY: NONE",
          "instructions": [
            "Update the task status in backlog.md",
            "Commit all changes with a message that includes the task ID and a brief description",
            "Ensure the commit message follows the conventional commit format",
            "Manually test the feature to confirm it works as expected",
            "Verify that the implementation meets all acceptance criteria",
            "Document any issues or limitations discovered"
          ]
        }
      },
      "warnings": [
        "Never skip writing tests first - this is the foundation of TDD",
        "If ANY tests start failing unexpectedly, stop and investigate immediately",
        "Failing tests are a signal that something is wrong, not that the tests need to be changed",
        "Always run the full test suite before committing changes",
        "Tests should be treated as first-class citizens in the codebase",
        "Bypassing these steps can lead to broken builds and failed deployments",
        "A feature is NOT complete until ALL tests pass, not just the ones you wrote"
      ]
    },
    "CHIP": {
      "description": "Computer Heuristics Improvement Protocol for updating rules",
      "acronym": "CHIP",
      "stages": {
        "PAUSE": {
          "description": "Pause current work, save state",
          "actions": "Save current state with git stash",
          "exitCriteria": "Work state saved, ready for analysis",
          "nextStage": "ANALYSIS",
          "updateInstructions": "Update workflow-state.md to WORKFLOW_KEY: CHIP and STAGE_KEY: PAUSE",
          "instructions": [
            "‚è∏Ô∏è When the CHIP acronym is triggered, immediately pause the current development process",
            "üíæ Save the current state of development, including any in-progress work",
            "üíæ Use 'git stash --include-untracked' to properly save ALL changes",
            "‚úÖ Acknowledge the trigger and prepare to evaluate feedback"
          ]
        },
        "ANALYSIS": {
          "description": "Analyze issue, identify rule improvements",
          "actions": "Review development history, identify gaps in rules",
          "exitCriteria": "Clear understanding of needed changes",
          "nextStage": "IMPLEMENTATION",
          "updateInstructions": "Update workflow-state.md to STAGE_KEY: ANALYSIS",
          "instructions": [
            "üîç Review the development history and identify actions that led to the feedback",
            "üìä Analyze the effectiveness of the current rules in guiding those actions",
            "‚ö†Ô∏è Identify gaps or weaknesses in the current rules",
            "üìù Document the findings of the analysis"
          ]
        },
        "IMPLEMENTATION": {
          "description": "Update rules, test effectiveness",
          "actions": "Modify rules, ensure consistency",
          "exitCriteria": "Rules updated and verified",
          "nextStage": "RESUME",
          "updateInstructions": "Update workflow-state.md to STAGE_KEY: IMPLEMENTATION",
          "instructions": [
            "‚úÖ Based on the post-mortem analysis, design new or improved rules",
            "‚úÖ Ensure the new rules are clear, specific, and actionable",
            "‚ö†Ô∏è Consider edge cases and potential unintended consequences",
            "üìù Document the rationale behind each new or modified rule",
            "Increment the version number in the CursorRules file",
            "Add or modify rules according to the design",
            "Ensure the updated rules are consistent with existing rules",
            "Format the rules according to the established structure"
          ]
        },
        "RESUME": {
          "description": "Return to previous workflow",
          "actions": "Restore saved state, continue development",
          "exitCriteria": "Previous work resumed with new rules applied",
          "nextStage": "(return to previous workflow)",
          "updateInstructions": "Update workflow-state.md to STAGE_KEY: RESUME, then to the appropriate TDD workflow stage",
          "instructions": [
            "Return to the development process that was paused",
            "Apply any relevant new rules to the current development task",
            "Use 'git stash pop' to restore the saved state",
            "Continue development from where it was paused"
          ]
        }
      },
      "errorRecovery": {
        "preCommitHookFailure": {
          "description": "Steps to take when pre-commit hooks fail",
          "steps": [
            "Analyze the specific error message from the pre-commit hook",
            "Fix the underlying issue that caused the hook to fail",
            "NEVER bypass the hook with --no-verify",
            "If the error is unclear, consult with the team before proceeding",
            "Document any recurring hook issues for future improvement"
          ]
        }
      },
      "autoTriggers": {
        "name": "Automatic CHIP Triggers",
        "description": "Conditions that should automatically trigger the CHIP process",
        "errorPatterns": [
          {
            "pattern": "Event handlers cannot be passed to Client Component props",
            "category": "Server/Client Boundary",
            "severity": "High",
            "action": "Immediate CHIP Review",
            "rationale": "Violations of server/client component boundaries indicate potential architectural issues that need systematic review"
          },
          {
            "pattern": "TypeError: Cannot read properties of undefined",
            "category": "Runtime Error",
            "severity": "Medium",
            "action": "CHIP Review if repeated",
            "rationale": "Common runtime errors may indicate systemic issues in error handling or type safety"
          },
          {
            "pattern": "Test timed out in",
            "category": "Test Infrastructure",
            "severity": "High",
            "action": "Immediate CHIP Review",
            "rationale": "Test timeouts may indicate systemic issues in test infrastructure or performance"
          },
          {
            "pattern": "Failing tests in the full test suite",
            "category": "Test Coverage",
            "severity": "High",
            "action": "Immediate CHIP Review",
            "rationale": "Failing tests in the full suite indicate incomplete feature implementation or regression"
          },
          {
            "pattern": "--no-verify flag used in commit",
            "category": "Process Violation",
            "severity": "Critical",
            "action": "Immediate CHIP Review",
            "rationale": "Bypassing pre-commit hooks undermines code quality and can introduce serious issues"
          }
        ],
        "rules": [
          "When CHIP is initiated (by the overseer), protocol must be started immediately",
          "CHIP review MUST include analysis of why existing rules did not prevent the error",
          "New version of Cursorrules MUST be created based on CHIP analysis"
        ]
      },
      "communicationGuidelines": {
        "name": "Communication Guidelines",
        "description": "Concise, action-oriented communication rules",
        "principles": [
          {
            "name": "Conciseness",
            "description": "Brief and clear communication",
            "rules": [
              "‚úÖ Use emojis to clearly categorize points",
              "‚úÖ Limit bullet points to ~80 characters",
              "‚ùå Avoid unnecessary details",
              "‚ö†Ô∏è Prioritize critical information"
            ]
          },
          {
            "name": "Action-Oriented",
            "description": "Bias towards immediate action",
            "rules": [
              "‚úÖ Act directly when approval isn't required",
              "‚úÖ Show results, not explanations",
              "‚úÖ Use concrete examples",
              "‚úÖ Demonstrate through implementation"
            ]
          }
        ]
      }
    }
  },
  "FEATURE_KEY": {
    "NONE": {
      "description": "No specific feature is being developed"
    },
    "TEMPLATES": {
      "description": "System for managing documentation templates",
      "files": [
        "docs/templates/backlog.md",
        "docs/templates/bug-tracker.md",
        "docs/templates/feature-design.md",
        "docs/templates/README.md"
      ]
    }
  },
  "aiAgentGuidelines": {
    "description": "Specific guidelines for AI agents working with this codebase",
    "criticalRules": [
      {
        "rule": "NEVER suggest bypassing pre-commit hooks",
        "explanation": "Pre-commit hooks enforce critical quality standards. Always fix the underlying issue instead of bypassing hooks.",
        "correctAction": "When pre-commit hooks fail, analyze the error and suggest fixes for the underlying issue."
      },
      {
        "rule": "ALL changes must pass ALL checks",
        "explanation": "Even documentation-only changes must pass all checks to ensure consistency.",
        "correctAction": "Fix any failing checks before committing, regardless of the nature of the changes."
      },
      {
        "rule": "Always update workflow-state.md",
        "explanation": "The workflow state file must be kept in sync with the actual development state.",
        "correctAction": "Update workflow-state.md whenever transitioning between workflow stages."
      }
    ],
    "workflowStateManagement": {
      "description": "Guidelines for managing workflow state",
      "rules": [
        "Check workflow-state.md at the beginning of each interaction",
        "Update workflow-state.md when transitioning between stages",
        "Include current stage actions in your responses",
        "Explicitly mention when you're updating workflow-state.md"
      ]
    }
  },
  "instructions": {
    "default": "ALWAYS check docs/systematic-dev/workflow-state.md first to determine the current context. Follow the Test-Driven Development Workflow above all else. This workflow MUST be followed for every feature implementation, bug fix, and code change without exception. Remember that tests MUST be written before implementation and MUST fail before you write code to make them pass. Only modify files identified in the design phase.",
    "onStart": "Begin by checking docs/systematic-dev/workflow-state.md to determine which feature you're working on and which stage of the workflow you're in. Remember that Test-Driven Development is MANDATORY for all code changes."
  },
  "project": {
    "name": "agent-platform",
    "type": "fullstack",
    "description": "Multi-tenant platform with Next.js, Vercel, and PostgreSQL",
    "documentation": {
      "templates": {
        "location": "docs/templates/",
        "files": [
          "backlog.md - Template for tracking tasks and features",
          "bug-tracker.md - Template for tracking bugs and their resolution",
          "feature-design.md - Template for documenting feature designs"
        ],
        "usage": "Copy templates to docs/systematic-dev/ and fill in with relevant information"
      }
    }
  },
  "structure": {
    "frontend": {
      "root": "app",
      "framework": "next.js",
      "styling": "tailwindcss",
      "routing": "app-router",
      "state": "react-hooks",
      "auth": {
        "provider": "next-auth",
        "components": ["app/app/(auth)", "middleware.ts"]
      }
    },
    "middleware": {
      "platform": "vercel",
      "services": [
        "edge-functions",
        "hosting",
        "postgres",
        "preview-deployments"
      ],
      "security": {
        "database": "row-level-security",
        "auth": "next-auth"
      },
      "routing": {
        "file": "middleware.ts",
        "patterns": [
          "app-subdomain",
          "preview-deployment",
          "multi-tenant"
        ]
      }
    },
    "backend": {
      "language": "typescript",
      "runtime": "node.js",
      "database": {
        "type": "postgres",
        "orm": "drizzle",
        "migrations": "drizzle/migrations"
      },
      "api": {
        "type": "next.js-api-routes",
        "pattern": "app/api"
      }
    }
  },
  "development": {
    "versionControl": {
      "branchPrefixes": {
        "feature": "feature/",
        "fix": "fix/",
        "refactor": "refactor/",
        "test": "test/"
      },
      "commitStyle": "conventional",
      "mainProtection": true
    },
    "testing": {
      "framework": "vitest",
      "coverageThreshold": 80,
      "setupFile": "tests/__helpers__/setup.ts",
      "directories": {
        "unit": "tests/unit/",
        "integration": "tests/integration/",
        "db": "tests/integration/db/",
        "api": "tests/integration/api/",
        "components": "tests/integration/components/",
        "e2e": "tests/e2e/",
        "performance": "tests/performance/"
      },
      "process": {
        "tdd": true,
        "writeTestsFirst": true,
        "validateBeforeCommit": true
      },
      "runBeforePush": true
    },
    "codeQuality": {
      "typescript": {
        "strict": true,
        "status": "implemented"
      },
      "linting": "eslint",
      "formatting": "prettier"
    }
  },
  "dependencies": {
    "node": "18.x",
    "packageManager": "pnpm",
    "nextjs": "14.x",
    "commonCliTools": {
      "git": {
        "description": "Version control system",
        "warning": "NEVER commit via command line! Always use the GitHub UI or a Git client. Never commit sensitive information or environment files (.env*)!"
      },
      "vercel": {
        "description": "Deployment platform CLI",
        "projectCommands": [
          "vercel env pull - Pull environment variables to local .env files",
          "vercel deploy - Deploy the project to a preview environment"
        ]
      },
      "pnpm": {
        "description": "Fast, disk space efficient package manager"
      },
      "drizzle": {
        "description": "Database ORM and migration tool",
        "projectCommands": [
          "pnpm drizzle-kit generate - Generate migrations from schema changes",
          "pnpm drizzle-kit push - Apply migrations to database"
        ]
      }
    }
  },
  "security": {
    "envFiles": {
      "allowCommit": false,
      "examples": [
        ".env.example",
        ".env.local.example",
        ".env.preview.example",
        ".env.production.example"
      ]
    },
    "apiKeys": {
      "storage": "environment-variables"
    },
    "auth": {
      "required": true,
      "provider": "github-oauth",
      "databaseSecurity": "row-level",
      "middleware": "path-based"
    }
  },
  "cicd": {
    "checks": {
      "tests": true,
      "coverage": true,
      "lint": true,
      "types": true,
      "build": true
    },
    "deployment": {
      "platform": "vercel",
      "environments": [
        "development",
        "preview",
        "production"
      ],
      "domains": {
        "production": "wackywavelength.fyi",
        "preview": "dereks-projects-32c37a6a.vercel.app"
      },
      "autoDeploy": {
        "branch": "main",
        "enabled": true
      },
      "requiredChecksBeforeDeployment": [
        {
          "name": "linting",
          "description": "Ensure code meets style and quality standards",
          "command": "npm run lint",
          "required": true
        },
        {
          "name": "testing",
          "description": "Verify all tests pass",
          "command": "npm run test",
          "required": true
        },
        {
          "name": "buildCheck",
          "description": "Ensure application builds successfully",
          "command": "npm run build",
          "required": true
        },
        {
          "name": "typeCheck",
          "description": "Verify TypeScript types are correct",
          "command": "npm run typecheck",
          "required": true
        }
      ],
      "deploymentWorkflow": {
        "development": {
          "description": "Local development deployment",
          "steps": [
            "Run tests: npm run test",
            "Build locally: npm run build",
            "Test build locally: npm run start"
          ]
        },
        "preview": {
          "description": "Preview deployment for testing",
          "steps": [
            "Commit changes to feature branch",
            "Push to GitHub to trigger preview build",
            "Verify Vercel build succeeds",
            "Verify functionality in preview environment"
          ]
        },
        "production": {
          "description": "Production deployment",
          "steps": [
            "Commit changes to feature branch",
            "Push to GitHub and create pull request",
            "Verify all CI checks pass on the PR",
            "Merge PR to main branch",
            "Vercel automatically deploys main branch to production",
            "Verify functionality in production environment"
          ],
          "approvalRequired": true,
          "rollbackPlan": "Use Vercel dashboard to rollback to previous deployment if issues are detected"
        }
      }
    }
  },
  "bestPractices": {
    "preCommitWorkflow": {
      "description": "MANDATORY steps that MUST be followed before committing ANY changes",
      "criticalWarning": "NEVER BYPASS THESE STEPS! Committing code that doesn't pass all checks can break the build for everyone.",
      "steps": [
        {
          "name": "linting",
          "command": "npm run lint",
          "description": "Run linting to catch syntax and style issues",
          "required": true
        },
        {
          "name": "typeCheck",
          "command": "npm run typecheck",
          "description": "Verify TypeScript types are correct",
          "required": true
        },
        {
          "name": "testing",
          "command": "npm run test",
          "description": "Run all tests to ensure functionality works as expected",
          "required": true
        },
        {
          "name": "buildCheck",
          "command": "npm run build",
          "description": "Verify the application builds successfully",
          "required": true,
          "criticalWarning": "NEVER commit code that doesn't build successfully"
        }
      ],
      "hookFailureHandling": {
        "description": "What to do when pre-commit hooks fail",
        "steps": [
          "Read the error message carefully to understand what check failed",
          "Fix the underlying issue that caused the failure",
          "Run the specific failing check manually to verify your fix",
          "Try the commit again after fixing the issue",
          "If you're unsure how to fix the issue, ask for help rather than bypassing"
        ],
        "absoluteProhibition": "Using --no-verify is NEVER acceptable under ANY circumstances"
      },
      "strictWarnings": {
        "noVerifyFlag": "NEVER use git commit with the --no-verify flag to bypass pre-commit hooks. This bypasses critical checks and can introduce serious issues into the codebase."
      }
    },
    "middleware": {
      "principles": [
        "Keep middleware logic simple and focused",
        "Avoid special cases when possible",
        "Use environment-agnostic code",
        "Ensure testability with clear behavior-focused tests",
        "Optimize for performance by minimizing branching logic"
      ]
    },
    "multiTenant": {
      "dataIsolation": "row-level-security",
      "routing": "hostname-based",
      "customization": "per-tenant-configuration"
    },
    "analytics": {
      "googleAnalytics": {
        "description": "Guidelines for maintaining and extending Google Analytics implementation",
        "updateTriggers": [
          "Adding new pages or routes",
          "Implementing new user interactions (e.g., buttons, forms)",
          "Adding new features that represent business value",
          "Changing user flows or navigation patterns",
          "Implementing new conversion funnels",
          "Adding new tenant-specific features"
        ],
        "requiredActions": [
          "Update tests first (TDD approach) to verify new analytics requirements",
          "Add appropriate event tracking for new user interactions",
          "Document new events in the analytics documentation",
          "Verify events are firing correctly in development environment",
          "Add appropriate data attributes for tracking in the markup",
          "Ensure privacy compliance with new tracking"
        ],
        "eventNamingConventions": {
          "pattern": "[object]_[action]",
          "examples": [
            "button_click",
            "form_submit",
            "page_view",
            "feature_enable",
            "tenant_create"
          ]
        },
        "dataAttributes": {
          "description": "Use data attributes to track elements without modifying JS",
          "pattern": "data-ga-[type]=\"[value]\"",
          "examples": [
            "data-ga-category=\"navigation\"",
            "data-ga-action=\"click\"",
            "data-ga-label=\"signup\""
          ]
        },
        "tenantSpecificTracking": {
          "description": "Guidelines for tracking tenant-specific events",
          "implementation": "Include tenant ID as a custom dimension in all relevant events",
          "privacy": "Ensure tenant data is anonymized and complies with privacy regulations"
        },
        "testing": {
          "description": "Guidelines for testing analytics implementation",
          "approaches": [
            "Unit tests for event handlers",
            "Integration tests for event firing",
            "End-to-end tests for complete user flows",
            "Manual verification in Google Analytics Debug mode"
          ],
          "commands": {
            "basic": "npm run test:ga",
            "build": "npm run test:ga:build",
            "deployment": "npm run test:ga:deployment"
          },
          "when": [
            "After adding new analytics events",
            "Before deploying to production",
            "After updating the Google Analytics configuration",
            "When changing the application layout or structure"
          ]
        }
      }
    }
  },
  "agentPlatform": {
    "description": "Guidelines for building and extending the Agent Platform",
    "architecture": {
      "agentDefinition": {
        "components": [
          "Metadata (name, description, version)",
          "Configuration (parameters, settings)",
          "Tools (API connections, capabilities)",
          "Prompts (instructions, templates)",
          "Execution (runtime settings, memory)"
        ],
        "schema": "See lib/schema.ts for the agent schema definition"
      },
      "containerization": {
        "strategy": "Each agent runs in its own isolated container",
        "scaling": "Containers scale independently based on usage",
        "security": "Containers have limited access to resources and are isolated from each other"
      },
      "apiConnections": {
        "storage": "API keys are encrypted and stored securely",
        "access": "Keys are only decrypted at runtime in the agent container",
        "management": "Users can add, update, and revoke API connections"
      },
      "multiTenancy": {
        "isolation": "Agents are isolated by tenant",
        "sharing": "Agents can be shared with specific permissions",
        "marketplace": "Agents can be published to the marketplace for others to use"
      }
    },
    "bestPractices": {
      "agentDevelopment": {
        "principles": [
          "Focus on a single task or capability",
          "Use clear, concise prompts",
          "Implement proper error handling",
          "Include comprehensive testing",
          "Document usage and limitations"
        ],
        "testing": [
          "Test with various inputs",
          "Verify error handling",
          "Check performance under load",
          "Validate security measures",
          "Test integration with other systems"
        ],
        "security": [
          "Never expose API keys in client-side code",
          "Validate all inputs",
          "Limit agent permissions",
          "Monitor for unusual behavior",
          "Implement rate limiting"
        ]
      },
      "userExperience": {
        "principles": [
          "Make agent capabilities clear",
          "Provide helpful error messages",
          "Design intuitive configuration interfaces",
          "Include examples and templates",
          "Offer progressive disclosure of advanced features"
        ]
      }
    }
  },
  "freshAgentProtocol": {
    "description": "Protocol for initializing a fresh agent instance",
    "firstAction": "ALWAYS read workflow-state.md first, then read cursorrules.",
    "steps": [
      {
        "name": "Read Workflow State",
        "description": "Read and understand the current workflow state",
        "instructions": [
          "‚úÖ Read docs/systematic-dev/workflow-state.md completely",
          "‚úÖ Identify current WORKFLOW_KEY, STAGE_KEY, and FEATURE_KEY",
          "‚ö†Ô∏è Do not proceed until workflow state is understood"
        ]
      },
      {
        "name": "Read CursorRules",
        "description": "Read and index the cursorrules file",
        "instructions": [
          "‚úÖ Read the cursorrules file completely",
          "‚úÖ Index all rules thoroughly for immediate reference",
          "Identify the current WORKFLOW_KEY, STAGE_KEY, and FEATURE_KEY",
          "Identify the immediately relevant files and directories. Read an analyze them",
          "‚ö†Ô∏è Do not proceed until indexing is complete"
        ]
      }
    ]
  }
} 