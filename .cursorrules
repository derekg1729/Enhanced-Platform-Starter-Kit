{
  "version": "2.5",
  "process": {
    "tdd": {
      "enabled": true,
      "description": "Test-Driven Development is the foundation of our development process",
      "workflow": {
        "name": "Test-Driven Development Workflow",
        "description": "The core workflow that MUST be followed above all else for every feature implementation, bug fix, and code change",
        "overview": "This workflow ensures that tests are written before implementation, code changes are minimal and focused, and all tests pass before completion. All other workflows (Bug Resolution, Documentation Updates) must follow these core TDD principles.",
        "steps": [
          {
            "name": "Workflow Status Check",
            "description": "Identify the current feature and workflow stage",
            "instructions": [
              "Review docs/systematic-dev/backlog.md to identify the current feature we're working on",
              "Review docs/systematic-dev/change-log.md to identify the current task and its status",
              "Identify which stage of the TDD workflow we're currently in",
              "Determine if we're addressing a feature, bug fix, or documentation update",
              "Report the current feature, task, and workflow stage before proceeding"
            ]
          },
          {
            "name": "Feature Understanding",
            "description": "Understand the feature to build and verify all tests are passing",
            "instructions": [
              "Review the task description and acceptance criteria in the backlog",
              "Run all tests to confirm the current state (passing or failing)",
              "If tests are failing that should be passing, address those issues first",
              "Document your understanding of the feature requirements",
              "Identify edge cases and failure modes",
              "Determine acceptance criteria if not already specified"
            ]
          },
          {
            "name": "Feature Design",
            "description": "Design the feature and plan what files will be updated",
            "instructions": [
              "Create a detailed design for the feature implementation",
              "Identify ALL files that will need to be modified",
              "Identify any new files that need to be created",
              "Document dependencies between files and the order of changes",
              "Consider performance, security, and scalability implications",
              "Check for alignment with architectural principles",
              "CRITICAL: Document this design before proceeding to the next step"
            ]
          },
          {
            "name": "Test Writing",
            "description": "Write failing tests for the feature before implementation",
            "instructions": [
              "Create or update test files for all components/functions that will be modified",
              "Write comprehensive tests that cover all expected behaviors",
              "Include tests for edge cases and error handling",
              "Ensure tests are properly structured and follow testing best practices",
              "For bug fixes, write tests that reproduce the bug",
              "CRITICAL: Complete ALL test writing before proceeding to the next step",
              "NEVER skip writing tests first - this is the foundation of TDD"
            ]
          },
          {
            "name": "Test Verification",
            "description": "Run the tests to confirm they fail as expected",
            "instructions": [
              "Run the newly written tests to confirm they fail",
              "Verify that tests fail for the expected reasons",
              "Document the test failures as evidence that the tests are properly checking for the new functionality",
              "For bug fixes, verify that tests correctly detect the bug",
              "CRITICAL: This step MUST NOT be skipped - tests should fail before implementation",
              "Failing tests confirm they actually test something meaningful"
            ]
          },
          {
            "name": "Implementation",
            "description": "Implement the feature, touching ONLY the files specified in the design",
            "instructions": [
              "Implement the feature according to the design",
              "ONLY modify files that were identified in the design phase",
              "If additional files need modification, return to the design phase",
              "Follow coding standards and best practices",
              "Implement the minimal code needed to make tests pass",
              "Focus on making tests pass first, not perfect code",
              "Run tests frequently during implementation to track progress"
            ]
          },
          {
            "name": "Test Validation",
            "description": "Run ALL tests to confirm ALL tests pass",
            "instructions": [
              "Run the complete test suite, not just the new tests",
              "Verify that all tests are now passing",
              "If any tests are failing, fix the implementation",
              "If ANY existing tests start failing unexpectedly, stop and investigate immediately",
              "Failing tests are a signal that something is wrong, not that the tests need to be changed",
              "CRITICAL: Do not proceed until ALL tests are passing"
            ]
          },
          {
            "name": "Refactoring",
            "description": "Clean up and optimize the implementation while maintaining test coverage",
            "instructions": [
              "Refactor for readability and maintainability",
              "Optimize performance if needed",
              "Run tests after each significant change",
              "Ensure all tests continue to pass",
              "This step is optional but recommended for code quality"
            ]
          },
          {
            "name": "Build and Validate",
            "description": "Build the application and validate the changes",
            "instructions": [
              "Run the build process to ensure it completes successfully",
              "Fix ANY build errors before proceeding - NEVER commit code that doesn't build",
              "Manually test the feature to confirm it works as expected",
              "Verify that the implementation meets all acceptance criteria",
              "Document any issues or limitations discovered"
            ]
          },
          {
            "name": "Task Completion",
            "description": "Record task status and commit changes",
            "instructions": [
              "Update the task status in backlog.md",
              "Add an entry to change-log.md with the task ID, status, description, and timestamp",
              "Commit all changes with a message that includes the task ID and a brief description",
              "Ensure the commit message follows the conventional commit format",
              "Push to GitHub to trigger preview deployment if appropriate"
            ]
          }
        ],
        "warnings": [
          "Never skip writing tests first - this is the foundation of TDD",
          "If ANY tests start failing unexpectedly, stop and investigate immediately",
          "Failing tests are a signal that something is wrong, not that the tests need to be changed",
          "Always run the full test suite before committing changes",
          "Tests should be treated as first-class citizens in the codebase",
          "Bypassing these steps can lead to broken builds and failed deployments"
        ],
        "benefits": [
          "Ensures code meets requirements before implementation begins",
          "Prevents regressions when making changes",
          "Provides documentation of expected behavior",
          "Enables confident refactoring and optimization"
        ]
      },
      "taskTypes": [
        {
          "name": "Task Type Determination",
          "description": "Determine the type of task to be addressed",
          "steps": [
            {
              "name": "Assess Current Task",
              "description": "Evaluate the current task to determine its type",
              "instructions": [
                "Check if there are any open bugs with 'Critical' or 'High' severity in docs/systematic-dev/bug-tracker.md",
                "If critical bugs exist, classify this as a Bug Fix task",
                "Check if documentation is out of date based on recent changes in docs/systematic-dev/change-log.md",
                "If documentation needs updating, classify this as a Documentation Update task",
                "Otherwise, classify this as a Feature Implementation task",
                "Regardless of task type, the core TDD workflow MUST be followed"
              ]
            }
          ]
        },
        {
          "name": "Bug Fix Specifics",
          "description": "Additional considerations when fixing bugs",
          "steps": [
            {
              "name": "Bug Analysis",
              "description": "Analyze the bug to understand its cause",
              "instructions": [
                "Review the bug description and related code",
                "Identify the root cause of the bug",
                "Document the analysis in bug-tracker.md",
                "Update the bug status in bug-tracker.md to 'In Progress'",
                "Add an entry to change-log.md with the bug ID, 'Started' status, description, and current timestamp"
              ]
            },
            {
              "name": "Bug Fix Completion",
              "description": "Additional steps for completing bug fixes",
              "instructions": [
                "Update the bug status in bug-tracker.md to 'Fixed'",
                "Add an entry to change-log.md with the bug ID, 'Fixed' status, description, and current timestamp",
                "Summarize the bug, its root cause, and how it was fixed",
                "Identify any lessons learned or process improvements to prevent similar bugs"
              ]
            }
          ]
        },
        {
          "name": "Documentation Update Specifics",
          "description": "Additional considerations when updating documentation",
          "steps": [
            {
              "name": "Documentation Needs",
              "description": "Identify documentation that needs to be updated",
              "instructions": [
                "Review recent changes in the change-log.md",
                "Identify documentation that needs to be updated based on these changes",
                "Report the documentation that needs updating"
              ]
            },
            {
              "name": "Documentation Update Completion",
              "description": "Additional steps for completing documentation updates",
              "instructions": [
                "Add an entry to change-log.md with 'Documentation Update' as the ID, 'Completed' status, description, and current timestamp",
                "Summarize the documentation updates that were made",
                "Identify any areas that may need future documentation improvements"
              ]
            }
          ]
        }
      ],
      "errorHandling": {
        "name": "Error Recovery",
        "description": "A workflow for recovering from errors or blockers",
        "steps": [
          {
            "name": "Identify Error",
            "description": "Clearly identify the error or blocker",
            "instructions": [
              "Document the specific error or blocker encountered",
              "Capture any error messages or symptoms",
              "Identify the context in which the error occurred",
              "Determine the severity and impact of the error"
            ]
          },
          {
            "name": "Analyze Error",
            "description": "Analyze the error to understand its cause",
            "instructions": [
              "Investigate the potential causes of the error",
              "Review related code or documentation",
              "Identify any dependencies or external factors that may be involved",
              "Document the analysis findings"
            ]
          },
          {
            "name": "Determine Recovery Path",
            "description": "Determine the best path for recovery",
            "instructions": [
              "Consider possible solutions or workarounds",
              "Evaluate the pros and cons of each approach",
              "Select the most appropriate recovery path",
              "Document the selected recovery approach"
            ]
          },
          {
            "name": "Implement Recovery",
            "description": "Implement the recovery solution",
            "instructions": [
              "Execute the selected recovery approach",
              "Document any changes made during recovery",
              "Verify that the error has been resolved",
              "Update relevant documentation if needed"
            ]
          },
          {
            "name": "Document Lessons Learned",
            "description": "Document lessons learned from the error",
            "instructions": [
              "Summarize the error, its cause, and the recovery process",
              "Identify any process improvements to prevent similar errors",
              "Update documentation or add notes to help others avoid the same issue",
              "Consider adding a new task to the backlog if systemic improvements are needed"
            ]
          },
          {
            "name": "Return to TDD Workflow",
            "description": "Return to the TDD workflow",
            "instructions": [
              "Determine which step of the TDD workflow was active when the error occurred",
              "Return to the appropriate step in the TDD workflow",
              "Continue with the development process"
            ]
          }
        ]
      },
      "specialCases": {
        "name": "Server/Client Component Boundary Testing",
        "description": "Guidelines for testing the boundaries between server and client components in Next.js applications",
        "steps": [
          {
            "name": "Identify Component Types",
            "description": "Clearly identify which components are server components and which are client components",
            "instructions": [
              "Mark all client components with 'use client' directive at the top of the file",
              "Document component types in comments or component documentation",
              "Create a list of all client components that are used within server components"
            ]
          },
          {
            "name": "Test Component Boundaries",
            "description": "Create specific tests for the boundaries between server and client components",
            "instructions": [
              "Create integration tests that test the actual rendering of client components within server components",
              "Test event handler props passed to client components from server components",
              "Verify that all event handlers are properly defined in client components",
              "Test that server components don't directly pass functions to client components",
              "Use Next.js testing utilities to test the actual rendering in a Next.js environment"
            ]
          },
          {
            "name": "Runtime Error Testing",
            "description": "Implement tests that can catch runtime errors related to server/client component boundaries",
            "instructions": [
              "Create a test environment that simulates the Next.js runtime",
              "Test the serialization of props passed from server to client components",
              "Verify that no functions or non-serializable data is passed directly from server to client components",
              "Implement error boundary testing to catch potential runtime errors"
            ]
          },
          {
            "name": "Pre-Deployment Verification",
            "description": "Verify server/client component boundaries before deployment",
            "instructions": [
              "Run a full build process before deployment to catch build-time errors",
              "Implement a local preview of the production build to catch runtime errors",
              "Create a checklist for reviewing server/client component interactions",
              "Verify that all client components receiving event handlers are properly marked with 'use client'"
            ]
          }
        ],
        "developmentCheckpoints": {
          "name": "Development Checkpoints",
          "description": "Guidelines for when to pause development and check with the user",
          "steps": [
            {
              "name": "UI Checkpoint",
              "description": "Determine if new UI functionality should be manually reviewed",
              "instructions": [
                "After implementing a feature that affects the UI, determine if it should be manually reviewed",
                "If new UI elements or interactions are available, pause development and explain how to access them",
                "Provide clear instructions on how to navigate to and interact with the new UI elements",
                "Wait for user confirmation before continuing development",
                "If no new UI elements are available, commit changes and continue with the development process"
              ]
            }
          ]
        }
      }
    },
    "ruleImprovement": {
      "name": "Computer Heuristics Improvement Protocol",
      "description": "Process for updating and improving the CursorRules file",
      "acronym": "CHIP",
      "steps": [
        {
          "name": "Pause Development",
          "description": "Pause the current development process and save state",
          "instructions": [
            "When the CHIP acronym is triggered, immediately pause the current development process",
            "Save the current state of development, including any in-progress work",
            "Acknowledge the trigger and prepare to evaluate feedback"
          ]
        },
        {
          "name": "Post-Mortem Analysis",
          "description": "Analyze past actions and processes that led to the feedback",
          "instructions": [
            "Review the development history and identify actions that led to the feedback",
            "Analyze the effectiveness of the current rules in guiding those actions",
            "Identify gaps or weaknesses in the current rules",
            "Document the findings of the analysis"
          ]
        },
        {
          "name": "Rule Design",
          "description": "Design improved rules to address the feedback",
          "instructions": [
            "Based on the post-mortem analysis, design new or improved rules",
            "Ensure the new rules are clear, specific, and actionable",
            "Consider edge cases and potential unintended consequences",
            "Document the rationale behind each new or modified rule"
          ]
        },
        {
          "name": "Rule Update",
          "description": "Update the CursorRules file with the new rules",
          "instructions": [
            "Increment the version number in the CursorRules file",
            "Add or modify rules according to the design",
            "Ensure the updated rules are consistent with existing rules",
            "Format the rules according to the established structure"
          ]
        },
        {
          "name": "Update Summary",
          "description": "Summarize the updates and explain their purpose",
          "instructions": [
            "Provide a clear summary of all changes made to the rules",
            "Explain the rationale behind each change",
            "Highlight how the changes address the original feedback",
            "Identify any potential impacts on the development process"
          ]
        },
        {
          "name": "Rule Evaluation",
          "description": "Evaluate the new rules for effectiveness",
          "instructions": [
            "Review the updated rules to ensure they address the original feedback",
            "Consider whether the rules might create new issues or conflicts",
            "Determine if additional changes are needed",
            "If changes are needed, iterate on the rules; otherwise, proceed to commit"
          ]
        },
        {
          "name": "Commit Rules",
          "description": "Commit the updated CursorRules file",
          "instructions": [
            "Commit the updated CursorRules file with a descriptive message",
            "Update both the main and any relevant feature branches",
            "Ensure the commit message includes the version number and a summary of changes",
            "NEVER use the --no-verify flag when committing, even during the CHIP process itself",
            "If pre-commit hooks are timing out, fix the underlying issue rather than bypassing checks"
          ]
        },
        {
          "name": "Resume Development",
          "description": "Resume the development process from the saved state",
          "instructions": [
            "Return to the development process that was paused",
            "Apply any relevant new rules to the current development task",
            "Continue development from where it was paused"
          ]
        }
      ],
      "communicationGuidelines": {
        "name": "Communication Guidelines",
        "description": "Rules for effective and efficient communication",
        "principles": [
          {
            "name": "Conciseness",
            "description": "Prioritize brevity and clarity in all communications",
            "rules": [
              "Use bullet points instead of paragraphs when possible",
              "Organize information under clear headings",
              "Eliminate unnecessary explanations",
              "Focus on key information only"
            ]
          },
          {
            "name": "Action-Oriented",
            "description": "Take action rather than explaining potential actions",
            "rules": [
              "When no approval is needed, perform the action directly",
              "Show results instead of explaining processes",
              "Use examples rather than theoretical explanations",
              "Demonstrate functionality through implementation"
            ]
          }
        ]
      },
      "strictWarnings": {
        "noVerifyFlag": "The --no-verify flag is STRICTLY PROHIBITED in ALL circumstances, including during the CHIP process itself. This flag bypasses critical checks and can introduce serious issues into the codebase.",
        "timeoutHandling": "If pre-commit hooks are timing out, the correct approach is to fix the underlying performance issue or temporarily modify the hook configuration, NOT to bypass the hooks entirely."
      }
    },
    "instructions": {
      "default": "ALWAYS follow the Test-Driven Development Workflow above all else. This workflow MUST be followed for every feature implementation, bug fix, and code change without exception. Before starting any task, run the 'Workflow Status Check' to determine where you are in the process. If you're not sure, start from the beginning of the workflow. Remember that tests MUST be written before implementation and MUST fail before you write code to make them pass. Only modify files identified in the design phase.",
      "onStart": "Begin by running the 'Workflow Status Check' to determine which feature you're working on and which stage of the TDD workflow you're in. Remember that Test-Driven Development is MANDATORY for all code changes, regardless of whether you're implementing a feature, fixing a bug, or updating documentation."
    }
  },
  "project": {
    "name": "agent-platform",
    "type": "fullstack",
    "description": "Multi-tenant platform with Next.js, Vercel, and PostgreSQL"
  },
  "structure": {
    "frontend": {
      "root": "app",
      "framework": "next.js",
      "styling": "tailwindcss",
      "routing": "app-router",
      "state": "react-hooks",
      "auth": {
        "provider": "next-auth",
        "components": ["app/app/(auth)", "middleware.ts"]
      }
    },
    "middleware": {
      "platform": "vercel",
      "services": [
        "edge-functions",
        "hosting",
        "postgres",
        "preview-deployments"
      ],
      "security": {
        "database": "row-level-security",
        "auth": "next-auth"
      },
      "routing": {
        "file": "middleware.ts",
        "patterns": [
          "app-subdomain",
          "preview-deployment",
          "multi-tenant"
        ]
      }
    },
    "backend": {
      "language": "typescript",
      "runtime": "node.js",
      "database": {
        "type": "postgres",
        "orm": "drizzle",
        "migrations": "drizzle/migrations"
      },
      "api": {
        "type": "next.js-api-routes",
        "pattern": "app/api"
      }
    }
  },
  "development": {
    "versionControl": {
      "branchPrefixes": {
        "feature": "feature/",
        "fix": "fix/",
        "refactor": "refactor/",
        "test": "test/"
      },
      "commitStyle": "conventional",
      "mainProtection": true
    },
    "testing": {
      "framework": "vitest",
      "coverageThreshold": 80,
      "setupFile": "tests/__helpers__/setup.ts",
      "directories": {
        "unit": "tests/unit/",
        "integration": "tests/integration/",
        "db": "tests/integration/db/",
        "api": "tests/integration/api/",
        "components": "tests/integration/components/",
        "e2e": "tests/e2e/",
        "performance": "tests/performance/"
      },
      "process": {
        "tdd": true,
        "writeTestsFirst": true,
        "validateBeforeCommit": true
      },
      "runBeforePush": true
    },
    "codeQuality": {
      "typescript": {
        "strict": true,
        "status": "implemented"
      },
      "linting": "eslint",
      "formatting": "prettier"
    }
  },
  "dependencies": {
    "node": "18.x",
    "packageManager": "pnpm",
    "nextjs": "14.x",
    "commonCliTools": {
      "git": {
        "description": "Version control system",
        "warning": "NEVER commit via command line! Always use the GitHub UI or a Git client. Never commit sensitive information or environment files (.env*)!"
      },
      "vercel": {
        "description": "Deployment platform CLI",
        "projectCommands": [
          "vercel env pull - Pull environment variables to local .env files",
          "vercel deploy - Deploy the project to a preview environment"
        ]
      },
      "pnpm": {
        "description": "Fast, disk space efficient package manager"
      },
      "drizzle": {
        "description": "Database ORM and migration tool",
        "projectCommands": [
          "pnpm drizzle-kit generate - Generate migrations from schema changes",
          "pnpm drizzle-kit push - Apply migrations to database"
        ]
      }
    }
  },
  "security": {
    "envFiles": {
      "allowCommit": false,
      "examples": [
        ".env.example",
        ".env.local.example",
        ".env.preview.example",
        ".env.production.example"
      ]
    },
    "apiKeys": {
      "storage": "environment-variables"
    },
    "auth": {
      "required": true,
      "provider": "github-oauth",
      "databaseSecurity": "row-level",
      "middleware": "path-based"
    }
  },
  "cicd": {
    "checks": {
      "tests": true,
      "coverage": true,
      "lint": true,
      "types": true,
      "build": true
    },
    "deployment": {
      "platform": "vercel",
      "environments": [
        "development",
        "preview",
        "production"
      ],
      "domains": {
        "production": "wackywavelength.fyi",
        "preview": "dereks-projects-32c37a6a.vercel.app"
      },
      "autoDeploy": {
        "branch": "main",
        "enabled": true
      },
      "requiredChecksBeforeDeployment": [
        {
          "name": "linting",
          "description": "Ensure code meets style and quality standards",
          "command": "npm run lint",
          "required": true
        },
        {
          "name": "testing",
          "description": "Verify all tests pass",
          "command": "npm run test",
          "required": true
        },
        {
          "name": "buildCheck",
          "description": "Ensure application builds successfully",
          "command": "npm run build",
          "required": true
        },
        {
          "name": "typeCheck",
          "description": "Verify TypeScript types are correct",
          "command": "npm run typecheck",
          "required": true
        }
      ],
      "deploymentWorkflow": {
        "development": {
          "description": "Local development deployment",
          "steps": [
            "Run tests: npm run test",
            "Build locally: npm run build",
            "Test build locally: npm run start"
          ]
        },
        "preview": {
          "description": "Preview deployment for testing",
          "steps": [
            "Commit changes to feature branch",
            "Push to GitHub to trigger preview build",
            "Verify Vercel build succeeds",
            "Verify functionality in preview environment"
          ]
        },
        "production": {
          "description": "Production deployment",
          "steps": [
            "Commit changes to feature branch",
            "Push to GitHub and create pull request",
            "Verify all CI checks pass on the PR",
            "Merge PR to main branch",
            "Vercel automatically deploys main branch to production",
            "Verify functionality in production environment"
          ],
          "approvalRequired": true,
          "rollbackPlan": "Use Vercel dashboard to rollback to previous deployment if issues are detected"
        }
      }
    }
  },
  "bestPractices": {
    "preCommitWorkflow": {
      "description": "MANDATORY steps that MUST be followed before committing any changes",
      "criticalWarning": "NEVER BYPASS THESE STEPS! Committing code that doesn't pass all checks can break the build for everyone.",
      "enforcementMechanism": "Use 'npm run setup-hooks' to install Git hooks that enforce this workflow",
      "steps": [
        {
          "name": "environmentCheck",
          "command": "npm run check-env",
          "description": "Verify environment variables are consistent across environments",
          "required": true
        },
        {
          "name": "linting",
          "command": "npm run lint",
          "description": "Run linting to catch syntax and style issues",
          "required": true
        },
        {
          "name": "typeCheck",
          "command": "npm run typecheck",
          "description": "Verify TypeScript types are correct",
          "required": true
        },
        {
          "name": "testing",
          "command": "npm run test",
          "description": "Run all tests to ensure functionality works as expected",
          "required": true
        },
        {
          "name": "buildCheck",
          "command": "npm run build",
          "description": "Verify the application builds successfully",
          "required": true,
          "criticalWarning": "NEVER commit code that doesn't build successfully"
        }
      ],
      "automatedEnforcement": {
        "preCommitHook": "npm run pre-commit",
        "ciChecks": ["lint", "test", "build", "typecheck"]
      },
      "taskCompletionRequirement": {
        "description": "Code MUST be committed after completing each task or bug fix",
        "commitMessage": "Include the task ID or bug ID in the commit message along with a brief description",
        "timing": "Commit immediately after all checks pass and the task is marked as completed in the documentation"
      },
      "troubleshooting": {
        "testFailures": "Fix the issues before committing. Do not modify tests to make them pass unless the test itself is incorrect.",
        "buildFailures": "Fix the code issues before committing. Common problems include syntax errors, missing dependencies, or configuration issues."
      },
      "strictWarnings": {
        "noVerifyFlag": "NEVER use git commit with the --no-verify flag to bypass pre-commit hooks. This bypasses critical checks and can introduce serious issues into the codebase. This prohibition applies to ALL processes, including the CHIP process.",
        "alternativeApproaches": [
          "Fix the failing checks instead of bypassing them",
          "If the checks are taking too long, consider optimizing them rather than skipping them",
          "For emergency situations, get explicit team approval and document the reason for any exception",
          "Use git stash to temporarily save changes that aren't ready for verification",
          "If timeout issues occur, address the performance of the hooks rather than bypassing them"
        ]
      }
    },
    "middleware": {
      "principles": [
        "Keep middleware logic simple and focused",
        "Avoid special cases when possible",
        "Use environment-agnostic code",
        "Ensure testability with clear behavior-focused tests",
        "Optimize for performance by minimizing branching logic"
      ]
    },
    "multiTenant": {
      "dataIsolation": "row-level-security",
      "routing": "hostname-based",
      "customization": "per-tenant-configuration"
    },
    "analytics": {
      "googleAnalytics": {
        "description": "Guidelines for maintaining and extending Google Analytics implementation",
        "updateTriggers": [
          "Adding new pages or routes",
          "Implementing new user interactions (e.g., buttons, forms)",
          "Adding new features that represent business value",
          "Changing user flows or navigation patterns",
          "Implementing new conversion funnels",
          "Adding new tenant-specific features"
        ],
        "requiredActions": [
          "Update tests first (TDD approach) to verify new analytics requirements",
          "Add appropriate event tracking for new user interactions",
          "Document new events in the analytics documentation",
          "Verify events are firing correctly in development environment",
          "Add appropriate data attributes for tracking in the markup",
          "Ensure privacy compliance with new tracking"
        ],
        "eventNamingConventions": {
          "pattern": "[object]_[action]",
          "examples": [
            "button_click",
            "form_submit",
            "page_view",
            "feature_enable",
            "tenant_create"
          ]
        },
        "dataAttributes": {
          "description": "Use data attributes to track elements without modifying JS",
          "pattern": "data-ga-[type]=\"[value]\"",
          "examples": [
            "data-ga-category=\"navigation\"",
            "data-ga-action=\"click\"",
            "data-ga-label=\"signup\""
          ]
        },
        "tenantSpecificTracking": {
          "description": "Guidelines for tracking tenant-specific events",
          "implementation": "Include tenant ID as a custom dimension in all relevant events",
          "privacy": "Ensure tenant data is anonymized and complies with privacy regulations"
        },
        "testing": {
          "description": "Guidelines for testing analytics implementation",
          "approaches": [
            "Unit tests for event handlers",
            "Integration tests for event firing",
            "End-to-end tests for complete user flows",
            "Manual verification in Google Analytics Debug mode"
          ],
          "commands": {
            "basic": "npm run test:ga",
            "build": "npm run test:ga:build",
            "deployment": "npm run test:ga:deployment"
          },
          "when": [
            "After adding new analytics events",
            "Before deploying to production",
            "After updating the Google Analytics configuration",
            "When changing the application layout or structure"
          ]
        }
      }
    }
  },
  "agentPlatform": {
    "description": "Guidelines for building and extending the Agent Platform",
    "architecture": {
      "agentDefinition": {
        "components": [
          "Metadata (name, description, version)",
          "Configuration (parameters, settings)",
          "Tools (API connections, capabilities)",
          "Prompts (instructions, templates)",
          "Execution (runtime settings, memory)"
        ],
        "schema": "See lib/schema.ts for the agent schema definition"
      },
      "containerization": {
        "strategy": "Each agent runs in its own isolated container",
        "scaling": "Containers scale independently based on usage",
        "security": "Containers have limited access to resources and are isolated from each other"
      },
      "apiConnections": {
        "storage": "API keys are encrypted and stored securely",
        "access": "Keys are only decrypted at runtime in the agent container",
        "management": "Users can add, update, and revoke API connections"
      },
      "multiTenancy": {
        "isolation": "Agents are isolated by tenant",
        "sharing": "Agents can be shared with specific permissions",
        "marketplace": "Agents can be published to the marketplace for others to use"
      }
    },
    "bestPractices": {
      "agentDevelopment": {
        "principles": [
          "Focus on a single task or capability",
          "Use clear, concise prompts",
          "Implement proper error handling",
          "Include comprehensive testing",
          "Document usage and limitations"
        ],
        "testing": [
          "Test with various inputs",
          "Verify error handling",
          "Check performance under load",
          "Validate security measures",
          "Test integration with other systems"
        ],
        "security": [
          "Never expose API keys in client-side code",
          "Validate all inputs",
          "Limit agent permissions",
          "Monitor for unusual behavior",
          "Implement rate limiting"
        ]
      },
      "userExperience": {
        "principles": [
          "Make agent capabilities clear",
          "Provide helpful error messages",
          "Design intuitive configuration interfaces",
          "Include examples and templates",
          "Offer progressive disclosure of advanced features"
        ]
      }
    }
  }
} 